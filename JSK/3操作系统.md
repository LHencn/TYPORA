#### 操作系统作用：

1. 软件的搭载平台
2. 为用户软件程序提供访问硬件资源的标准界面
3. 保证用户程序不受其他用户程序侵害
4. 并统筹管理所有硬件资源，将复杂的界面抽象为简单的界面

#### 类似的抽象实例：

- 后端工程师从数据结构中选取前端需要的部分、设计端点endpoint（即一特定URL）
- 用户通过该URL访问远端服务器的数据

#### 理解操作系统的并行：

1. 为了提高软件的表现，将一任务拆分为可平行运行的多部分，在设备上同时运行
2. 难点：解决并行可能引起的数据在多个线程中不一致的问题

#### 为什么要学习操作系统？

1. 认识操作系统，了解其作用
2. 理解操作系统的功能实现的过程中熟悉很多在软件设计中非常常见的设计问题
3. 理解多线程的实现方式和数据可靠性的实现方式
   1. 理解不同线程是如何共享资源
   2. 用来实现同步的基本工具是如何保证共享资源在多个线程中保持一致

#### 操作系统的前世今生

```c
"I think there is a world market for maybe five computers."
       By Thomas Watson, chairman of IBM, 1943
```

1. 计算机刚出现时，硬件成本高昂，人力费用低廉，此时还没有操作系统，读程序、运行程序等基本功能由接线员来完成。
2. 硬件（集成电路中晶体管数量增多）发展、人力价格上涨，致使操作系统得以发展
3. 从早期只支持命令行运行的UNICS发展到支持图像用户界面、并行程序等
4. 随着电子技术的发展，操作系统被嵌入到各种需要数据计算与资源协调的设备
   1. 小到日常使用的电饭煲
   2. 大到核磁共振设备、航天器

#### 探讨方向

我们来探讨一下基于不同装置的操作系统所面临的共同问题，并探索不同的解决方案，而不会涉及到基于某一具体装置（如火星探测器）的操作系统。

#### 为什么要有操作系统？

市面上不同的电脑可能具有不同的CPU，不同的硬件设备，还可能需要在不同的网络环境中运行，那我们程序猿还需要针对每台电脑不同的硬件组合写出不同的程序么？

答案显然是否定的，为了规避处理具体硬件接口的复杂性，我们是需要一个新的抽象层，它可以囊括所有不同的硬件组合，从而方便利用硬件资源，这个抽象层即操作系统。

#### 操作系统提供的抽象及其作用

1. 提供方便的用户接口（用户使用方便，程序猿开发软件考虑因素方便）
   1. 存储磁盘上多个位置的数据命名为一个文件，即文件抽象
   2. 基于进程的抽象
2. 防止恶意程序和含有bug的程序对计算机造成破坏

#### 文件和文件存储

1. 我们现在习惯于在目录中存储文件，但文件实际上只是存储在磁盘某一区域的一段二进制数，如果没有有关文件存储位置、文件大小的数据，那我们就不知道文件是在磁盘哪里开始，哪里结束。
2. 如果没有操作系统这个抽象层，那么我们就必须以某种形式储存我们的数据在磁盘上的位置（例如指针存储变量在内存中的位置），而这十分复杂。
3. 操作系统为我们管理磁盘上存储的数据，将一次存储在多个位置的数据结合在一起命名为一个文件，方便我们直接存取磁盘上的信息而不需要知道他们如何被存储的。
4. 不同操作系统对于文件系统的抽象方式是不同的。

#### 基于进程的抽象

1. 我们在使用计算机时总感觉程序是连续运行的，但实际由于计算机物理资源的有限性，一个程序在处理器上的运行大多时候是不连续的（这取决于操作系统进程调度所用的算法）
2. 计算机内核数量有限，不可能为所有程序提供全部处理器时间，一定会有程序在运行过程中被切换为另一个程序，一段时间后再继续执行。
3. 同样，计算机内存有限，一定会有一个程序的一部分内存被留在磁盘中，只有一些数据会实际存在于系统内存中
4. 因此我们在使用计算机时所认为的连续使用处理器、将全部数据存储在内存中的程序是不存在的，这种独占全部内存和处理器时间运行的程序来源于操作系统对于物理资源的抽象——进程。
5. 进程这种抽象大大方便了多个程序同时在系统中运行——程序设计者不需要考虑其他软件在内存中所占的大小和位置，也**不需要考虑上下文切换时切换内存 、保留处理器状态等复杂的过程**，而**只需要考虑自己所设计的程序在独占全部资源的理想状态下**的运行情况。
   1. 上下文切换即从一个进程切换到另一个进程的过程

#### 防止恶意程序和含有bug的程序对计算机造成破坏

1. 试想，如果进程可以直接与物理资源发生接触，那么一个进程就可以修改磁盘上所有的数据，直接导致数据丢失，使其他程序无法运行。
2. 操作系统作为一个抽象层可以在给用户进程提供服务的同时保证无相应权限的用户无法对物理资源进行利用，防止上述情况发生。
3. 同时，由于每个进程都在抽象的内存空间中进程读写操作，不能直接接触到其他进程的内存，这保护了每个进程不受其他恶意进程的侵害。

#### 操作系统抽象的应用：

1. 抽象使进程调度、上下文切换（从一个进程切换到另一个进程）对用户进程完全透明，防止用户进程敢于进程调度等操作系统的功能
2. 抽象迫使所有用户进程只能通过操作系统获得资源（如：用户进程必须通过操作系统读写磁盘上的文件，而不能直接读取磁盘），进而保护了资源不被恶意进程滥用
3. 抽象将磁盘上的数据划分为不同分区，并为之命名，方便人阅读
4. 抽象提供了简介的程序接口，使用户进程在不了解一些功能的具体实现方式的情况下仍能使用操作系统提供的这些功能（如系统调用fork()）

#### 操作系统的主要作用：

1. 提供公共服务

   操作系统通过对于裸机的抽象向用户进程提供了诸如读取、修改文件，与其他进程通信，或等待其他进程的服务。这些服务不要求用户进程理解操作系统对服务的实现方式和裸机的运行原理（例如：用户在打开文件时不需要知道文件存储在磁盘的那个位置以及操作系统是如何读取文件的），因此操作系统可以被视为一个友好的用户接口和公共服务的提供者。

2. 协调进程交互

   像上述一样，多个进程必须共享有限的物理资源，而这些进程并不知道自己和其他进程对于资源的实际调配。因此我们需要操作系统起到统筹规划的作用，给每个进程分配适当的处理器时间、内存和其他资源。进程间的同步和通信、在进程切换过程中处理器和告诉缓存器状态的变化、确保各个进程的正常运行等都属于操作系统的协调范围。

3. 管理与控制资源

   操作系统的一大作用是保证所有进程都可以正常运行，因此操作系统必须将有限的物理资源（处理器时间、内存、I/O设备时间）**合理地分配**给不同的进程，提高资源利用率，缩短交互进程响应时间，防止进程利用其他进程的资源或恶意干扰其运行

#### 操作系统内核

介绍完操作系统的作用许多同学大概会问：“我在安装系统的时候似乎不只安装了上述哪些功能啊？”

1. 么错，一般的操作系统安装盘除了带有上述功能以外往往还包括了很多别的部分，比如浏览器、文本编辑器、电子邮件服务等等。为了区分这些功能和我们刚才定义的操作系统的功能，我们把执行操作系统的核心功能（提供公共服务、协调进程交互、构建虚拟机、管控物理资源）的部分称为**操作系统内核**。
2. 不同于浏览器等程序，内核无时无刻不在计算机上运行——计算机启动时第一个运行的进程就是内核，所有用户进程都基于内核运行，所有资源管控、进程交互协调都由内核完成。

#### 系统空间和用户空间

我们将CPU运算的时间分为两部分：

1. 一部分时间里，内核在CPU上运行，分配资源给用户进程，决定下一个运行的进程
2. 另一部分时间里，用户进程在运行

​       鉴于用户进程必须通过内核获得资源，并且不能接触除自己的资源以外的资源，用户进程相对于内核拥有更少的权限和资源，而且内核必须与用户进程使用不同的存储空间，防止用户进程获得内核的信息。

​        我们将内核所用的存储空间称为**系统空间**（kernel space），用户有的空间称为**用户空间**（user space）。我们用两种不同的模式来区分用户与内核的不同权限，这种区分被称为**双模式操作**（dual mode operation）。两种模式由处理器中的一个**位**区分，当处理器要执行某些只允许在内核态执行的特权操作，它会先通过这个位判断当前是否处于内核态，如果一个进程企图越权操作，处理器就会**触发异常**，使进程被内核终止。

#### 系统调用

​	考虑到操作系统作为公共服务提供者的角色——如果其他进程完全不能接触内核，那么它们也就无法使用内核提供的诸如读写文件、进程间通信等服务。那咋办咧？？？

​	那为了在提供服务的同时确保安全（不允许用户进程直接使用内核态的功能），操作系统提供了一套给用户进程的服务，即系统调用，使用户进程可以在固定的位置进入系统空间，使用系统提供的服务。所有系统调用程序地址被存放在存储器某一位置，被称为**系统调用表**。

​	当然，恶意用户进程仍然可以通过使用空指针、超出缓冲区大小范围等办法对内核进行攻击，因此在设计内核时，我们必须在实现系统调用时检查用户空间指针的合理性后再将参数复制到系统空间，进行操作。

:bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front:::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front:

#### 用户态——>内核态

由用户态进入内核态方法：

1. 系统调用
2. 中断（由进程外部引起）
3. 异常

#### 异常

​	异常（exception），又名**内中断或同步中断**，是在进程运行过程中来自处理器内部的中断信号，这些中断信号可能源自程序的非法操作（如除数为0、超长度读取数组等）、硬件故障等，而他们的中断信号将引起内核中对应的异常处理程序处理。

#### 中断

​	中断又称为外中断（interrupt）或异步中断，即来自处理器之外的中断信号。包括：

- 时钟中断：即一个进程用完一定的处理器时间后，时钟会发出中断信号，使计算机进入内核态，决定下一个运行的进程
- 设备I/O中断

​        这些中断信号都会引发计算机切换到内核态，处理中断信号。需要注意的是如果同时有多个中断发生时，我们必须先处理其中一个。因此，不同中断信号有不同的优先等级，处理器会先处理优先等级高的中断，之后再处理优先等级低的中断。

​	如果在处理一个中断的过程中，出现了另一个优先等级更高的中断信号，那么处理器可能在完成处理这个中断信号前，切换到新的中断信号处理程序，这时我们就有了多重中断。有时为了避免中断占取过多的CPU时间，我们可以在处理中断信号的过程中屏蔽某一优先等级的中断信号或某个单独的中断信号。

​	与系统调用类似，x86系统将所有进入中断服务程序的地址按照一定顺序存储于存储器中某一位置，称为**中断向量表**（interrupt vector）这一向量表控制了用户进程进入系统的地址，保护内核不被篡改。

#### 习题——蒜头君的课本

下列三项活动是在内核空间、内核态下发生的：

1. 处理超过数组长度的异常

   原因：异常将引起内核中对应的异常处理程序来处理

2. 向新的文件里写句子

   原因：读写文件是由内核提供的服务

3. 从磁盘中读取纯文本文件

   原因：读写文件是由内核提供的服务

下列三项是在用户空间、用户态下发生的：

1. 在已读取的字符串中寻找“内核”两个字

   原因：查找功能并不涉及对硬件或进程的抽象，因此并不是操作系统提供的服务而是在用户空间、用户态下完成的

2. C语言里新建一个存放找到的字符串的数组

   原因：C语言里新建一个数组是用户进程使用自己已分配的一段内存，并不需要进入内核态。

## C语言复习

#### malloc与动态内存分配

```c
void* malloc(size_t size);
```

- 参数size表明需要分配的堆内存大小
- 返回值表示指向分配内存起始地址的指针

使用场景：

​	主要在一个函数要应用另一个函数的返回值时使用该函数：由于函数返回后，其栈所栈的内存会被回收，我们必须将需要被其他函数利用的值存放在堆内存中，并返回一个指向该内存的指针。

```c
void* realloc(void* ptr, size_t size);
```

这个函数能够将已经分配的堆内存扩充到size的大小，并返回指向扩充后的分配内存的起始地址的指针。

#### 我们来找错误

```c
#include <stdio.h>

int main(){
    char* test = "test";
    test[0] = 'j'; //内存常量区不可修改
    printf("This is a %s\n", test);
    char* test2 = malloc(4*sizeof(char));
    //C语言里不推荐强制转换malloc的返回值
    realloc(test2, 21);
    //realloc的返回值需要赋值给指针test2
    strcpy(test2, "This is a real test\n");
    printf("%s", test2);
    free(test2);
    //需要释放堆内存 free(test); 
    return 0;
}
```

#### 为什么C语言里不推荐强制转换malloc的返回值？

1. C里面从void *到其它类型的指针是自动转换的。
2. 在旧式的C编译器里，如果一个函数没有原型声明，那么编译器会认为这个函数返回int。那么，如果碰巧代码里忘记包含头文件<stdlib.h>或者<malloc.h>，那么编译器看到malloc调用时，会认为它返回一个int。



#### 常用的字符串函数

```c
char* strcpy(char * dest, char* src);
```

1. 将存放在src里的字符串复制到dest的字符串的函数，返回值是dest。
2. strcpy在复制字符串时会自动在末尾加上`\0`，因此`dest`的长度必须比`src`多至少**1个字符**；
3. 如果`dest`的长度小于`strlen(src) + 1`，在运行中就会报段错误（Segmentation Fault）。

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
size_t strlen(const char* str);
```

1. 头文件：`#include <string.h>`
2. strlen函数从输入的字符串str中找`\0`，返回从第一个字符到第一个`\0`的长度（不包括`\0`）
3. 注意：若用一个长度为100的数组存储了一个实际长度只有5的字符串，strlen会返回5，而不是100

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
char* strcat(char* dest, char* src);
```

1. 字符串拼接函数
2. 将src里存储的字符串接到dest的后面，返回值为dest

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
int strcmp(char* str1, char* str2);
```

1. 返回0，表示两个输入的字符串完全一致
2. 返回值大于0，str1>str2

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
char* strtok(char* str, const char* delimiters);
```

1. 采用这个函数将str字符串通过**分隔符分隔开**
2. delimiters是一个含有多个字符的字符串，其中每一个字符都是一个独立的分隔符，如`\n\t`中`\n`和`\t`分别可以作为独立的分隔符
3. strtok会修改原来的str，若想保留原有的字符串，最好先strcpy下噢
4. strtok会返回一个指向第一个由非分隔符字符的指针的分割片段；之后的每次调用，都把NULL作为第一个参数，如果调用成功就会返回下一个分割片段，如果已经到达str的末尾则会返回`NULL`

#### 习题：蒜头君的情书

```c
#include <stdio.h>
#include <string.h>

const int MAX_LENGTH = 256;

char* get_letter(void) {
    static char letter[1000000];
    letter[999999] = ' ';
    char *p = letter;
    int size = MAX_LENGTH;
    while (feof(stdin) == 0) {
        if (size == 0) {
            break;
        }
        fgets(p, size + 1, stdin);
        while (*p != '\0') {
            p++;
            size--;
        }
    }
    return letter;
}

int main() {
    char *str = get_letter();
    char *dest = " ,.\t\r\n\'\"";
    char *dest = ' ', '\t', '\n', '\"', '\r\n', '\'', ',', '.', '\0'}; //回车换行的区别
    char *pase = malloc(sizeof(char) * MAX_LENGTH);
    pase = strcpy(pase, str);
    char *p = strtok(pase, dest);
    int cnt = 0;
    do {
    	puts(p);
       	if (strcmp(p, "love") == 0) //字符串比较
            cnt += 1;
    } while (p = strtok(NULL, dest));
    printf("%d\n", cnt);
    free(pase);
    puts(str);
    return 0;
}

#undef MAX_LENGTH
```

#### memset与memcpy

```c
void * memset ( void * ptr, int value, size_t num );
```

1. 头文件：`#include <string.h>`
2. 可以对指定的任何位置的内存进行修改
3. memset将从ptr指针所指的位置开始、大小为num字节的内存中的每个字节设为所指定的数值value
4. 用途：这个函数在将一段不用的内存全部归零时非常实用
5. 优点：memset在系统自带的库文件中被优化过了，因为好多人使用呐，因此使用它的效率要高于采用循环简单实现的哟

```c
void * memcpy ( void * destination, const void * source, size_t num );
```

1. 功能：修改一段连续的内存
2. 将由`source`开始的长度为`num`字节的内存复制到由`destination`开始的长度为`num`字节的内存中
3. 与memset类似，它也是在编译器优化之后了的喽

#### **memset和memcpy使用注意**：

使用这两个函数时需要注意输入正确的num值，在一般的指针移动时，每次移动的字节数等于之后怎所指数据类型的大小。

```c
int* x = malloc(4*sizeof(int));
int* p = x;
p += 1; \\在这一行我们将指针向前移动了 4 个字节
```

但在`memset`和`memcpy`中，我们所输入的指针已经被函数变为了`void *`指针，所以每次只会移动一个字节。如果要把5个整数从内存中的一个位置复制到另一个位置，那么：

```c
size_t num = 5 * sizeof(int); //即 20 字节
```

#### C语言相关资源

1. [Linux man pages](http://linux.die.net/man/)
2. [Stack Overflow](http://stackoverflow.com/)
3. [CGDB](https://www.gnu.org/software/gdb/download/)
4. [Valgrind](http://valgrind.org/)
   1. 主要用于查看内存泄露、多线程同步等问题
   2. 用途：若分配后堆内存不释放，仍可能可以编译，而它会告诉你哪里出现了内存泄漏

## 进程

#### 进程为什么要有（虚拟）地址空间？

​	由于进程是不可以直接操纵物理地址的，这是由于计算机所拥有的物力资源有限，当多个程序同时运行时，它们不可能连续地在处理器上运行或占用全部内存，因此我们需要进程的抽象在用户的一侧隐藏上下文切换等细节。

​	进程作为运行的程序的抽象，包含了一个程序的运行状态和这个程序所用的**抽象内存及其中存储的数据**。

那么该进程的地址空间呢，就是该进程所拥有的抽象内存及其中存储的数据。

我们可以将进程笼统地看做是一个或多个线程与一个地址空间的结合。

​	那**进程在系统一侧又是如何实现的呢**？实现这一方式需要达到什么目的呢？

1. 一方面，我们设计的**进程的结构**必须能够囊括一个进程的运行状态，在由于中断、异常或系统调度进入内核态时我们应该能够将进程的运行状态放入内存中的某一位置，使我们可以在某一个时间点根据进程的优先级借着这次的进度再次运行该进程；
2. 另一方面，由于进程在用户一侧对内存进行了抽象，我们需要在系统一侧包含从抽象内存向物理内存和外存（磁盘等存储设备）的映射，以便通过抽象内存的地址获得物理地址和其中存储的数据。
3. 那为了实现目的1，即在进程中存储其运行状态，那么引入**进程控制块**，其中存储着处理器状态寄存器、指令计数器、栈指针、通用寄存器等代表进程目前运行状态的值。但这只是其中存储的一方面哦～
   1. 由于现代计算机往往多核或多处理器，程序可以并行，因此同一进程可能同时包含多个不同的运行状态。为了更好地区分进程在一个处理器上的运行状态和线程本身的运行状态，引入线程。
   2. 每个线程拥有一个线程控制块，用来存储上述提到的处理器状态寄存器、指令计数器、栈指针、通用寄存器等数值
   3. 同一进程中的所有线程共享地址空间

![](https://res.jisuanke.com/img/upload/20160523/d623ba5f1e352fe303ada7d6e4554aa74cc59e8f.png)

#### 地址空间映射方法——分页存储、分段存储

​	在**Base and Bound**方法中，系统一段连续的物理内存分配给一个进程，Base代表基地址，即系统分配给一个而进程的可用内存的起始地址，Bound代表这个进程可用的内存的最高地址。**为了读写物理内存，我们将基地址与抽象内存地址相加，获得实际地址**；只要实际地址不大于Bound，内核就会允许进程进行该操作。因此在这个方法中，为了实现进程地址空间的抽象，进程在系统一侧的数据结构中必须包括这段可用的内存的基地址、可用长度。

#### 进程控制块（Process Control Block, PCB）

存储上述提到的两方面数据，对于内核来说，它是进程存在的唯一标识。存储的信息：

1. 表示运行状态的线程信息
2. 实现地址转换的信息
3. 系统在调度进程时需要的信息，如进程号、进程所处状态、进程的优先级等

**注意：**

1. 不需要将整个地址空间中包含的地址及其数据都存储在PCB里，只需要可以帮助我们从抽象内存地址获得实际物理地址的方法，而实际数据仍然存储在内存的对应位置中。
2. 由于PCB中包含优先级、基地址、可用地址范围等用户进程不应该有权限修改的信息，用户进程不应该有权限修改PCB，因此我们将PCB存储在**内核空间**中。

#### 进程的状态

##### 进程的三态模型

1. 就绪、运行、等待
2. 处于就绪态的进程不会因为遇到任何事件而无法进入等待态
3. 处于等待太的进程在事件发生后考虑到优先级等问题，必须先回到就绪状态而不能直接运行

##### 进程的五态模型

1. 新建态：
   1. 对应着进程被创建时尚未加入就绪队列的状态
   2. 为了建立一个新的进程，内核需要给进程分配资源（如：建立PCB）、建立必要的管理信息
2. 终止态：
   1. 进程已经结束但尚未被系统撤销的状态
   2. 处于终止态虽然进程已经结束，但其获得的资源还未被系统回收，因此系统仍然可以获得该进程结束时的信息

##### 新建态和终止态的必要性

1. 如果我们允许一个进程在获得全部资源前就进入就绪队列，那么一个新进程可能在未获得全部资源前就开始运行，而产生错误（在另一个进程里通过系统调用创造了这个新的进程）
2. 若进程A创建了B而想要等待B运行完毕，从中获得一些信息，那么终止态的缺失可能导致B率先运行完毕后被系统撤销，使得A无法从B获得任何信息
3. UNIX系统中，若发生A创建B，那么在A从B获取信息前，B会一直停留在终止态；
4. 若B终止后，仍在运行的A迟迟没有从B中获取信息，那么新进程B就会称为我们所说的“僵尸进程”，停留在系统内存中，导致系统变慢（也就是说僵尸进程是一个必定经历的过程）

![进程的五态模型](https://res.jisuanke.com/img/upload/20160524/b49f9d2d90d601cb3ff832695ce1727592adba5b.png)

#### 进程对对碰

1. UNIX系统中终止态可能导致僵尸进程的存在
2. 不可以使新建态的进程直接进入就绪态（内核需要给新建态的进程分配资源PCB，建立必要的管理信息）
3. 终止态可以为需要从终止进程中获得信息的其他进程保留信息
4. 处于等待态的进程不可能被选为下一个运行的进程（需要经历就绪态）
5. 进程不能从就绪态进入等待态（进入等待态是因为运行时所需要的某个条件没满足，而对于就绪队列中的进程，我们无法预知未来当其进入运行态的时候这些条件是否满足，因此不需要使其进入等待态）

#### 父子进程

```c
pid_t fork(void);
```

1. fork()被包含在`unistd.h`中，这个函数不需要任何参数；
2. 会直接创建一个新的进程，将现在运行的进程的处理器状态、地址空间直接拷贝到新进程中，因此新进程也会从fork()对应的指令开始运行（因为之前的操作都会被拷贝过去，就没必要在运行一遍了）
3. fork()执行完后返回一个进程ID，在父进程中返回的ID为子进程的PID，而在子进程中返回的进程ID为0（表示该进程为子进程，所以一个fork()只会创建一个进程）

#### **进程结束**

```c
void exit(int status);
```

1. 一个进程在运行结束或产生重大错误（如：企图越权使用内核的特权指令）后会被系统终止
2. 我们在由fork()产生的**子程序**中也可以用exit()系统调用主动结束该程序
3. 头文件：`#include <stdlib.h>`
4. 参数status表示这个进程退出时的结束状态

```c
pid_t wait(int* stat_loc);
```

1. 当我们使用`exit()`结束一个子进程时，status会作为子进程的结束状态被提供给`wait()`的第一个参数
2. 头文件：`#include <sys/wait.h>`
3. 参数`stat_loc`，是一个可以被用来储存等待的进程的结束状态值（exit code，一个代表子进程是否成功退出的整数；如成功则为0，否则为对应的错误数字）的指针
4. 但我们也可以把参数`stat_loc`设为`NULL`，wait仍可以正常运行。
5. `wait()`会使**父进程**的状态变为等待态，直到父进程的所有子进程中的**一个**成功退出并返回结束状态值，父进程才可以进入就绪状态，准备继续运行
6. 如果在`wait()`被调用时已经有可用的结束状态值，那么`wait()`会立即返回。
7. `wait()`**返回值**是返回结束状态值的子进程的进程ID
8. 如果在等待过程中出现了错误（如已经没有可等待的子进程），那么`wait()`将返回`-1`。
9. **父进程不能直接等待子进程的子进程**（每一个进程的wait仅仅作用于它的直接子进程）

#### 习题练一练

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>

int main() {
    printf("%s\n", "我是鸣人！");
    /*YOUR CODE HERE*/
    int pid = fork();
	if (pid != 0) {
        int status;
        int result = wait(&status); //wait返回值为子进程的ID或着出现错误时的-1
        if (result == -1 || status != 0) {
            printf("%s\n", "可恶，又失败了，再来一次！");
            return -1;
        } else {
             printf("%s\n", "我负责性质变化！");
        }
    } else {
        int second_pid = fork();
        if (second_pid != 0) {
            int new_status;
        	int new_result = wait(&new_status);
        	if (new_result == -1 || new_status != 0) {
                exit(-1); //在子进程中正常退出返回0，异常退出返回-1，一层一层判断
        	} else {
                printf("%s\n", "我负责形态变化！");
            	exit(0);
            }
        } else {
            printf("%s\n", "我负责产生查克拉！");
            exit(0);
        }
    }
    return 0;
}
```

#### 创建进程的应用

1. 网络编程过程中，每当服务器接收到请求，主进程就会用`fork()`产生出一个进程，处理那个请求，父进程仍然会继续在网络上等待其他请求的到来（socket中的accept为类似的道理）

#### waitpid()

```c
pid_t waitpid(pid_t pid, int* stat_loc, int options);
```

1. `waitpid()`与`wait()`不同的一点在于我们可以通过在pid参数里指定一个进程标识ID来等待一个有特定的进程标识ID的进程——`当pid为一个大于0`的数的时候`waitpid`等待的就是`进程标识ID等于pid`的子进程
2. 当pid为-1时，我们等待所有子进程中的任何一个
3. 当pid为0时，我们等待所有进程组标识ID与父进程相同的子进程
4. 当pid小于-1时，我们任何进程组标识ID为pid的绝对值的进程
5. 参数stat_loc与`wait`中的参数一样
6. 参数options将一些针对这个函数的特殊的控制选项用`|`连接在一起

#### 如何让子进程执行与父进程完全不同的程序呢？——exec六函数

1. 背景：利用`fork()`返回的进程标识ID，可以在子进程中执行和父进程中不同的指令（判断fork()返回值是否为0）

2. 但如果要运行完全不同的程序，又该怎么做呢？

3. 新的系统调用`execve()`闪亮登场

   1. ```c
      int execve(const char* filename, char* const argv[], char* const envp[]);
      ```

   2. `execve()`将在现在运行的进程中以`argv`中存储的字符串为参数运行由`filename`指向的可执行程序，并将`envp`中存储的“变量=数值“对作为环境变量带入这个程序。

   3. 根据传统，argv中的第一个参数必须与filename一致，真正的参数从第二个开始

   4. execve会以filename的程序覆盖现在进程运行的程序，因此所有在execve函数之后的行都会**在execve失败之后被执行**（即execve成功即后面的行不执行）

   5. 可以通过在execve后加入打印语句等方法标识execve运行失败

4. 基于`execve()`的六个函数：

   ```c
   int execl(const char* path, const char* arg, ...);
   int execlp(const char* file, const char* arg, ...);
   int execle(const char* path, const char* arg, ..., char* const envp[]);
   
   int execv(const char* path, char* const argv[]);
   int execvp(const char* file, char* const argv[]);
   int execvpe(const char* file, char* const argv[], char* const envp[]);
   ```

   1. 都具有在现有的进城中打开某一可执行文件、覆盖现有程序执行的功能
   2. 可以将这些函数表示为：`exec + l/v + p/e/pe`
   3. 功能差异：
      1. `l/v`在参数上表现为`execl`类函数将所有参数作为一整个字符串代入，而`execv`类函数将参数分别放入一个字符串的数组中，将数组作为参数代入函数运行
      2. `p/e/pe`表现为包含p（代表path）的函数可以模仿计算机中shell的功能，在`file`中不含`/`时应用环境变量`PATH`中的目录来寻找可执行文件，而包含e（代表environment）的函数可以像execve一样将”变量=数值“对作为环境变量代入程序

5. exec六函数的常见用法是先由当前运行的进程调用`fork()`产生新进程，然后在新进程中用exec()六函数运行新程序

   1. 大家可能会认为这样应用`fork()`复制了全部父进程的地址空间后又马上弃置不用、浪费了很多CPU时间，但实际上Linux系统采用了`copy_on_write技术`，也就是说只有在某一个数据被修改时那个数据才会被实际复制到子进程的地址空间，所以当`fork()`之后直接运行exec()六函数时，父进程的地址空间不会被复制过来

#### 章节复习

```c
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int count = 0;

int main(){

    int pid = fork();
    if (pid==0){
        count++;
        int pid2 = fork();
        if (pid2 == 0){
            char** argv = (char**) malloc(3*sizeof(char*));
            argv[0] = "echo";
            argv[1] = "Hello!";
            argv[2] = NULL;
            int pid3 = fork();
            count++;
            if (pid3 == 0){
                count++;
                execvp("echo", argv);
                //execvp函数正常执行时其后代码均不执行，进程执行跳转的文件，其后程序抛弃
                printf("Count %d,",count);
                exit(0);
            } else {
                free(argv);
                wait(NULL);
                printf("%d,",count);
                exit(0);
            }
        } else {
            wait(NULL);
            printf("%d,",count);
            exit(0);
        }
    } else {
        wait(NULL);
        printf("%d.",count);
        return 0;
    }    
}
```

```c
输出： hello！
	  2,1,0.
```

### 项目实践：自制SHELL

目标功能：与bash shell类似，可以显示当前所在的目录，然后对输入的命令进行解释

**第一部分:   `log_t`**

实现shell之前，需要实现数据结构log_t，它相当与一个用链表实现的栈，作用是保存输入的每一条命令以便查找（采用头插法，头入头出）

```c
void log_init(log_t *l); //相当于log_t的构造函数，需要将l的head设置为NULL

void log_destroy(log_t *l); //相当于log_t的析构函数————回收一个log_t所占用的所有内存，并将head设置爱为NULL，如果head已经为NULL则直接返回

void log_push(log_t *l, const cahr *item);//把item插入到log_t的末尾。如果head为NULL，需要在这个函数中为log_t建立第一个节点并分配对应的内存空间

char *log_search(log_t* l, const char *prefix);//遍历整个log_t的链表，搜索是否有包含前缀prefix存在的字符串，如果有的话则返回这个字符串（只返回第一个），没有的话就直接返回NULL
```

**第二部分：shell**

一个shell相当于一个无限循环的程序，它在循环中应该执行这些操作：

- 向标准输出打印一个命令提示符
- 从标准输入读取一个命令
- 判断要执行哪些命令

需要用到的函数：

```c
char *getcwd( char *buffer, int maxlen );//获取当前目录
ssize_t getline(char **lineptr, size_t *n, FILE *stream);//读取文件流中的一行
 int chdir(const char *path);//改变当前目录
```























