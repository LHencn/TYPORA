##### 操作系统作用：

1. 软件的搭载平台
2. 为用户软件程序提供访问硬件资源的标准界面
3. 保证用户程序不受其他用户程序侵害
4. 并统筹管理所有硬件资源，将复杂的界面抽象为简单的界面

##### 类似的抽象实例：

- 后端工程师从数据结构中选取前端需要的部分、设计端点endpoint（即一特定URL）
- 用户通过该URL访问远端服务器的数据

##### 理解操作系统的并行：

1. 为了提高软件的表现，将一任务拆分为可平行运行的多部分，在设备上同时运行
2. 难点：解决并行可能引起的数据在多个线程中不一致的问题

##### 为什么要学习操作系统？

1. 认识操作系统，了解其作用
2. 理解操作系统的功能实现的过程中熟悉很多在软件设计中非常常见的设计问题
3. 理解多线程的实现方式和数据可靠性的实现方式
   1. 理解不同线程是如何共享资源
   2. 用来实现同步的基本工具是如何保证共享资源在多个线程中保持一致

##### 操作系统的前世今生

```c
"I think there is a world market for maybe five computers."
       By Thomas Watson, chairman of IBM, 1943
```

1. 计算机刚出现时，硬件成本高昂，人力费用低廉，此时还没有操作系统，读程序、运行程序等基本功能由接线员来完成。
2. 硬件（集成电路中晶体管数量增多）发展、人力价格上涨，致使操作系统得以发展
3. 从早期只支持命令行运行的UNICS发展到支持图像用户界面、并行程序等
4. 随着电子技术的发展，操作系统被嵌入到各种需要数据计算与资源协调的设备
   1. 小到日常使用的电饭煲
   2. 大到核磁共振设备、航天器

##### 探讨方向

我们来探讨一下基于不同装置的操作系统所面临的共同问题，并探索不同的解决方案，而不会涉及到基于某一具体装置（如火星探测器）的操作系统。

##### 为什么要有操作系统？

市面上不同的电脑可能具有不同的CPU，不同的硬件设备，还可能需要在不同的网络环境中运行，那我们程序猿还需要针对每台电脑不同的硬件组合写出不同的程序么？

答案显然是否定的，为了规避处理具体硬件接口的复杂性，我们是需要一个新的抽象层，它可以囊括所有不同的硬件组合，从而方便利用硬件资源，这个抽象层即操作系统。

##### 操作系统提供的抽象及其作用

1. 提供方便的用户接口（用户使用方便，程序猿开发软件考虑因素方便）
   1. 存储磁盘上多个位置的数据命名为一个文件，即文件抽象
   2. 基于进程的抽象
2. 防止恶意程序和含有bug的程序对计算机造成破坏

##### 文件和文件存储

1. 我们现在习惯于在目录中存储文件，但文件实际上只是存储在磁盘某一区域的一段二进制数，如果没有有关文件存储位置、文件大小的数据，那我们就不知道文件是在磁盘哪里开始，哪里结束。
2. 如果没有操作系统这个抽象层，那么我们就必须以某种形式储存我们的数据在磁盘上的位置（例如指针存储变量在内存中的位置），而这十分复杂。
3. 操作系统为我们管理磁盘上存储的数据，将一次存储在多个位置的数据结合在一起命名为一个文件，方便我们直接存取磁盘上的信息而不需要知道他们如何被存储的。
4. 不同操作系统对于文件系统的抽象方式是不同的。

##### 基于进程的抽象

1. 我们在使用计算机时总感觉程序是连续运行的，但实际由于计算机物理资源的有限性，一个程序在处理器上的运行大多时候是不连续的（这取决于操作系统进程调度所用的算法）
2. 计算机内核数量有限，不可能为所有程序提供全部处理器时间，一定会有程序在运行过程中被切换为另一个程序，一段时间后再继续执行。
3. 同样，计算机内存有限，一定会有一个程序的一部分内存被留在磁盘中，只有一些数据会实际存在于系统内存中
4. 因此我们在使用计算机时所认为的连续使用处理器、将全部数据存储在内存中的程序是不存在的，这种独占全部内存和处理器时间运行的程序来源于操作系统对于物理资源的抽象——进程。
5. 进程这种抽象大大方便了多个程序同时在系统中运行——程序设计者不需要考虑其他软件在内存中所占的大小和位置，也**不需要考虑上下文切换时切换内存 、保留处理器状态等复杂的过程**，而**只需要考虑自己所设计的程序在独占全部资源的理想状态下**的运行情况。
   1. 上下文切换即从一个进程切换到另一个进程的过程

##### 防止恶意程序和含有bug的程序对计算机造成破坏

1. 试想，如果进程可以直接与物理资源发生接触，那么一个进程就可以修改磁盘上所有的数据，直接导致数据丢失，使其他程序无法运行。
2. 操作系统作为一个抽象层可以在给用户进程提供服务的同时保证无相应权限的用胡无法对物理资源进行利用，防止上述情况发生。
3. 同时，由于每个进程都在抽象的内存空间中进程读写操作，不能直接接触到其他进程的内存，这保护了每个进程不受其他恶意进程的侵害。

##### 操作系统抽象的应用：

1. 抽象使进程调度、上下文切换（从一个进程切换到另一个进程）对用户进程完全透明，防止用户进程敢于进程调度等操作系统的功能
2. 抽象破事所有用户进程只能通过操作系统获得资源（如：用户进程必须通过操作系统读写磁盘上的文件，而不能直接读取磁盘），进而保护了资源不被恶意进程滥用
3. 抽象将磁盘上的数据划分为不同分区，并为之命名，方便人阅读
4. 抽象提供了简介的程序接口，使用户进程在不了解一些功能的具体实现方式的情况下仍能使用操作系统提供的这些功能（如系统调用fork()）

##### 操作系统的主要作用：

1. 提供公共服务

   操作系统通过对于裸机的抽象向用户进程提供了诸如读取、修改文件，与其他进程通信，或等待其他进程的服务。这些服务不要求用户进程理解操作系统对服务的实现方式和裸机的运行原理（例如：用户在打开文件时不需要知道文件存储在磁盘的那个位置以及操作系统是如何读取文件的），因此操作系统可以被视为一个友好的用户接口和公共服务的提供者。

2. 协调进程交互

   像上述一样，多个进程必须共享有限的物理资源，而这些进程并不知道自己和其他进程对于资源的实际调配。因此我们需要操作系统起到统筹规划的作用，给每个进程分配适当的处理器时间、内存和其他资源。进程间的同步和通信、在进程切换过程中处理器和告诉缓存器状态的变化、确保各个进程的正常运行等都属于操作系统的协调范围。

3. 管理与控制资源

   操作系统的一大作用是保证所有进程都可以正常运行，因此操作系统必须将有限的物理资源（处理器时间、内存、I/O设备时间）**合理地分配**给不同的进程，提高资源利用率，缩短交互进程响应时间，防止进程利用其他进程的资源或恶意干扰其运行

##### 操作系统内核

介绍完操作系统的作用许多同学大概会问：“我在安装系统的时候似乎不只安装了上述哪些功能啊？”

1. 么错，一般的操作系统安装盘除了带有上述功能以外往往还包括了很多别的部分，比如浏览器、文本编辑器、电子邮件服务等等。为了区分这些功能和我们刚才定义的操作系统的功能，我们把执行操作系统的核心功能（提供公共服务、协调进程交互、构建虚拟机、管控物理资源）的部分称为**操作系统内核**。
2. 不同于浏览器等程序，内核无时无刻不在计算机上运行——计算机启动时第一个运行的进程就是内核，所有用户进程都基于内核运行，所有资源管控、进程交互协调都由内核完成。

##### 系统空间和用户空间

我们将CPU运算的时间分为两部分：

1. 一部分时间里，内核在CPU上运行，分配资源给用户进程，决定下一个运行的进程
2. 另一部分时间里，用户进程在运行

​       鉴于用户进程必须通过内核获得资源，并且不能接触除自己的资源以外的资源，用户进程相对于内核拥有更少的权限和资源，而且内核必须与用户进程使用不同的存储空间，防止用户进程获得内核的信息。

​        我们将内核所用的存储空间称为**系统空间**（kernel space），用户有的空间称为**用户空间**（user space）。我们用两种不同的模式来区分用户与内核的不同权限，这种区分被称为**双模式操作**（dual mode operation）。两种模式由处理器中的一个**位**区分，当处理器要执行某些只允许在内核态执行的特权操作，它会先通过这个位判断当前是否处于内核态，如果一个进程企图越权操作，处理器就会**触发异常**，使进程被内核终止。

##### 系统调用

​	考虑到操作系统作为公共服务提供者的角色——如果其他进程完全不能接触内核，那么它们也就无法使用内核提供的诸如读写文件、进程间通信等服务。那咋办咧？？？

​	那为了在提供服务的同时确保安全（不允许用户进程直接使用内核态的功能），操作系统提供了一套给用户进程的服务，即系统调用，使用户进程可以在固定的位置进入系统空间，使用系统提供的服务。所有系统调用程序地址被存放在存储器某一位置，被称为**系统调用表**。

​	当然，恶意用户进程仍然可以通过使用空指针、超出缓冲区大小范围等办法对内核进行攻击，因此在设计内核时，我们必须在实现系统调用时检查用户空间指针的合理性后再将参数复制到系统空间，进行操作。

:bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front:::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front::bullettrain_front:

##### 用户态——>内核态

由用户态进入内核态方法：

1. 系统调用
2. 中断（由进程外部引起）
3. 异常

##### 异常

​	异常（exception），又名**内中断或同步中断**，是在进程运行过程中来自处理器内部的中断信号，这些中断信号可能源自程序的非法操作（如除数为0、超长度读取数组等）、硬件故障等，而他们的中断信号将引起内核中对应的异常处理程序处理。

##### 中断

​	中断又称为外中断（interrupt）或异步中断，即来自处理器之外的中断信号。包括：

- 时钟中断：即一个进程用完一定的处理器时间后，时钟会发出中断信号，使计算机进入内核态，决定下一个运行的进程
- 设备I/O中断

​        这些中断信号都会引发计算机切换到内核态，处理中断信号。需要注意的是如果同时有多个中断发生时，我们必须先处理其中一个。因此，不同中断信号有不同的优先等级，处理器会先处理优先等级高的中断，之后再处理优先等级低的中断。

​	如果在处理一个中断的过程中，出现了另一个优先等级更高的中断信号，那么处理器可能在完成处理这个中断信号前，切换到新的中断信号处理程序，这时我们就有了多重中断。有时为了避免中断占取过多的CPU时间，我们可以在处理中断信号的过程中屏蔽某一优先等级的中断信号或某个单独的中断信号。

​	与系统调用类似，x86系统将所有进入中断服务程序的地址按照一定顺序存储于存储器中某一位置，称为**中断向量表**（interrupt vector）这一向量表控制了用户进程进入系统的地址，保护内核不被篡改。

##### 习题——蒜头君的课本

下列三项活动是在内核空间、内核态下发生的：

1. 处理超过数组长度的异常

   原因：异常将引起内核中对应的异常处理程序来处理

2. 向新的文件里写句子

   原因：读写文件是由内核提供的服务

3. 从磁盘中读取纯文本文件

   原因：读写文件是由内核提供的服务

下列三项是在用户空间、用户态下发生的：

1. 在已读取的字符串中寻找“内核”两个字

   原因：查找功能并不涉及对硬件或进程的抽象，因此并不是操作系统提供的服务而是在用户空间、用户态下完成的

2. C语言里新建一个存放找到的字符串的数组

   原因：C语言里新建一个数组是用户进程使用自己已分配的一段内存，并不需要进入内核态。

#### C语言复习

##### malloc与动态内存分配

```c
void* malloc(size_t size);
```

- 参数size表明需要分配的堆内存大小
- 返回值表示指向分配内存起始地址的指针

使用场景：

​	主要在一个函数要应用另一个函数的返回值时使用该函数：由于函数返回后，其栈所栈的内存会被回收，我们必须将需要被其他函数利用的值存放在堆内存中，并返回一个指向该内存的指针。

```c
void* realloc(void* ptr, size_t size);
```

这个函数能够将已经分配的堆内存扩充到size的大小，并返回指向扩充后的分配内存的起始地址的指针。

##### 我们来找错误

```c
#include <stdio.h>

int main(){
    char* test = "test";
    test[0] = 'j'; //内存常量区不可修改
    printf("This is a %s\n", test);
    char* test2 = malloc(4*sizeof(char));
    //C语言里不推荐强制转换malloc的返回值
    realloc(test2, 21);
    //realloc的返回值需要赋值给指针test2
    strcpy(test2, "This is a real test\n");
    printf("%s", test2);
    //需要释放堆内存 free(test); free(test2);
    return 0;
}
```

##### 为什么C语言里不推荐强制转换malloc的返回值？

1. C里面从void *到其它类型的指针是自动转换的。
2. 在旧式的C编译器里，如果一个函数没有原型声明，那么编译器会认为这个函数返回int。那么，如果碰巧代码里忘记包含头文件<stdlib.h>或者<malloc.h>，那么编译器看到malloc调用时，会认为它返回一个int。



##### 常用的字符串函数

```c
char* strcpy(char * dest, char* src);
```

1. 将存放在src里的字符串复制到dest的字符串的函数，返回值是dest。
2. strcpy在复制字符串时会自动在末尾加上`\0`，因此`dest`的长度必须比`src`多至少**1个字符**；
3. 如果`dest`的长度小于`strlen(src) + 1`，在运行中就会报段错误（Segmentation Fault）。

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
size_t strlen(const char* str);
```

1. 头文件：`#include <string.h>`
2. strlen函数从输入的字符串str中找`\0`，返回从第一个字符到第一个`\0`的长度（不包括`\0`）
3. 注意：若用一个长度为100的数组存储了一个实际长度只有5的字符串，strlen会返回5，而不是100

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
char* strcat(char* dest, char* src);
```

1. 字符串拼接函数
2. 将src里存储的字符串接到dest的后面，返回值为dest

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
int strcmp(char* str1, char* str2);
```

1. 返回0，表示两个输入的字符串完全一致
2. 返回值大于0，str1>str2

⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬⏬

```c
char* strtok(char* str, const char* delimiters);
```

1. 采用这个函数将str字符串通过**分隔符分隔开**
2. delimiters是一个含有多个字符的字符串，其中每一个字符都是一个独立的分隔符，如`\n\t`中`\n`和`\t`分别可以作为独立的分隔符
3. strtok会修改原来的str，若想保留原有的字符串，最好先strcpy下噢
4. strtok会返回一个指向第一个由非分隔符字符的指针的分割片段；之后的每次调用，都把NULL作为第一个参数，如果调用成功就会返回下一个分割片段，如果已经到达str的末尾则会返回`NULL`

##### 习题：蒜头君的情书

