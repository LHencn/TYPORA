#### 二分法

##### 特点：

- 应用广泛，用于**缩小问题的规模**
- 时间、空间效率较高
- 思路容易，编写易错，考察面试者思虑是否周全，及对细节的处理

##### 常见问题：

- 在一个有序、**无重复元素**的数组中找到某个关键字
- **找出满足条件的最大值or最小值**

##### 形式化描述：

1. 确定待查关键字在有序的查找表中的范围：`left = 0， right = length - 1`
2. 使用给定的关键字和查找表的mid元素比较
   1. 相等，查找成功
   2. 待查关键字比mid元素大，对右子表进行折半查找
   3. 待查关键字比mid元素小，对左子表进行折半查找
3. 如此重复，知道查找成功或范围缩小为空（left > right）即结束

##### 伪代码：

```c
find_key(arr, key) 
    left = 0, right = arr.length - 1
    while left <= right			//此处指的是left和right指向的值是可以取到的，所以当相等时依然进入循环，mid即指向他们指向的值
    	mid = (left + right) / 2
        if arr[mid] == key
        	return mid
        else if arr[mid] < key
        	left = mid + 1
        else 
            right = mid - 1
    return NOT_FOUND
```

##### 找出满足条件的最大值or最小值

**简单版本**：

对于给定的一个**由0和1**组成、且按照`0,0,0,…,0,1,1,…,1,1`的规则排列的数组，从中快速找出第一个**1**的位置

##### 伪代码：

```c
find_key(arr)
    left = 0, right = arr.length - 1
    while left < right	//right指向的值符合的是一个范围，若相等时仍然判断则陷入无限循环中
    	mid = (left + right) / 2
        if arr[mid] == 1	//相等时仍判断则陷入无限循环
            right = mid
        else 
            left = mid + 1
	if arr[right] == 1
        return right
    else 
        return -1
```

##### 问题一般化：

1. 对于某个限定条件，当因子的值超过某个阀值后，条件一定成立，反之一定不成立。可以利用这样的思想来找到那个阀值---也就是满足条件的因子的最小值
2. 第一类问题就是这其中的一个特例：限定条件是下标i对应的元素值`ai`不小于待查询的关键字`key`的值，因子就是数组的下标i。当下标较小时，`ai<key`；当下标较大时，`ai > key`，我们要查找的关键字在数组中的下标，实际上就是第一个满足`ai >= key`的下标
3. 二分法“万变不离其宗”，都是在解决一类问题---查找满足条件的最小值

##### 二分法进行数值计算

**求sqrt(k)伪代码：**

```c
get_sqrt(k)
    l = 0, r = k
    while r - l > eps
    	mid = (l + r) / 2
        if mid * mid <= k
        	l = mid
        else 
            r = mid
    return l
```

eps就是我们在数值计算中经常用到的无穷小量,常将其赋值为1e-6等数值(一般根据题目要求的误差精度而定,如果要求的精度误差为 10^(−3) ,则eps应该为1e-4或更小的值

##### 总结：

换个角度来理解这个问题----我们要求的√k 的值,实际上相当于,对于在`[0, inf)`上单调递增的函数 y=x^2^，找出满足` y = x^2 >= k`的最小的因子 x。

- 即是找出满足某个约束条件的最小的因子值
- 抽象为在第一象限内单调递增函数确定满足条件最小值

不仅是√k ,对于在某段区间内保持单调递增的函数，借助二分法,我们都能够不使用任何数学库来算出它的精度足够高的近似值，比如求
$$
y^2=x
$$
$x^2 $





