# 错题集

## 一、海贼题库顺序表与链表

1、具有n个节点的有序单链表中插入一个新节点的时间复杂度用数学方法如何计算？

当在第i个位置上插入时，i等于0、1、 2、 3、 ...、n，概率均相等，为1/（n+1)，i=0时，移动n个节点，i=1时，移动(n-2)个节点，i=n时，移动0个节点，平均移动节点个数=平均概率×n(0+n)/2 = O(n/2)；

```c
2、数组定义为”int a[4][5];”, 引用”*(a+1)+2″表示（）

 A、a[1][0]+2
 B、a数组第1行第2列元素的地址
 C、a[0][1]+2
 D、a数组第1行第2列元素的值
```

```c
解释：
二位数组的数组名代表行指针，有如下关系：
*(a+1)+2 <->a数组第1行第2列元素的地址
a代表行指针，不实际占用内存，类似一个人的名字，仅仅是一个标记
*a表示列指针   																		(B)
```

```c
3、关于 int a[10]; 问下面哪些不可以表示 a[1] 的地址？
A.a+sizeof(int)
B.&a[0]+1
C.(int*)&a+1 
D.(int*)((char*)&a+sizeof(int))
```

```c
解析：
sizeof(int) <-> 4
B/C 一个含义，数组首地址加1
D、数据地址先被转换为char*，然后加4，根据指针运算公式，向前移动4 * sizeof(char)，之后被转换为int*，显然是a[1]的地址
```

```c
4、设有 一个二维数组 A [m][n] ，假设 A [0][0] 存放位置在 644(10) ， A [2][2] 存放位置在 676(10) ，每个元素占一个空间，问 A [3][3](10) 存放在什么位置？脚注 (10) 表示用 10 进制表示。
-A、688 	-B、678	-C、692	-D、696
```

```c
解析：
676-644=32。（32-2）/2=15。说明有15列元素。 644+15*3+3=692
```

5、线性表：循环链表、队列、栈、空字符串数组、双向链表，关联数组不是线性表

6、对线性表进行折半查找时，要求线性表必须（）
解析：

​	以顺序方式存储，且结点按关键字有序排序	

​	折半查找（二分查找）：大部分均需关键字有序，但存在可不用有序的类型如：

​	已知一数组a[0]>a[1]，a[n-2]<a[n-1]，即数组左右两边呈U字，即至少存在数组中的一位，小于其左右的值，			找到这个值。

​	解析：采用二分法查找，中间值不论是大于或小于其左右值，范围均可缩小一倍。

7、有种数据结构叫跳跃列表（Skip List），它是一种基于并联的链表的随机化数据结构，其效率可比拟于二叉查找树（对于大于数操作需要O(log n)平均时间）。它是按层建造的。底层是一个普通的有序链表。每个更高层都充当下面列表的“快速跑道”，这里在层i中的元素按概率l/p出现在层i+1中。平均起来，每个元素都在p/(p-1)个列表中出现，而最高层的元素（通常是在跳跃列表前段的一个特殊的头元素）在O(logp n)个列表中出现。调节p的大小可以在内存消耗和时间消耗上进行折中。试分析在该数据结构中查找一个元素的平均时间复杂度。![img](https://www.haizeix.com/files/course/2018/07-09/1154328c92b3275602.png)

O（logn)

解析：二分查找的变化，效率类似

8、若对n阶对称矩阵A(下标从1,1开始）以行序为主序方式将其下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B[1…(n(n+1))/2]中,则在B中确定aij的位置k的关系为() 

解析：矩阵的下三角形  i>=j，a【i】【j】是第1+2+...+i-1+j=（i-1）*i/2+j个元素，故i*(i-1)/2+j

9、线性表是具有 n 个***数据元素***的有限序列(n>0)

10、下列关于数组与指针的区别描述正确的是？

- A.数组要么在静态存储区被创建（如全局数组），要么在栈上被创建。
- B.用运算符sizeof 可以计算出数组的容量（字节数）
- C.指针可以随时指向任意类型的内存块。
- D.用运算符sizeof 可以计算出指针所指向内容的容量（字节数）

解析：堆区间动态存储创建数组；const指针定义之后不可以更改指向；sizeof只能计算出指针变量的容量。

11、广义表：是对线性表和树的推广，并且具有共享和递归特性的广义表可以和有向图建立对应。

- D=(a，D)=(a，(a，(a，(…)))) 　　D的长度为2，第一个元素是原子，第二个元素是D自身，展开后它是一个无限的广义表。
- 一个表的"深度"是指表展开后所含括号的层数。
- 带名字的广义表表示 　　
  - 如果规定任何表都是有名字的，为了既表明每个表的名字，又说明它的组成，则可以在每个表的前面冠以该表的名字，于是上例中的各表又可以写成： 　　
  - ①E() 　　
  - ②L(a，b) 　　
  - ③A(x，L(a，b)) 　　
  - ④B(A(x，L(a，b))，y) 　　
  - ⑤C(A(x，l(a，b))，B(A(x，L(a，b))，y)) 　　
  - ⑥D(a，D(a，D(…)))
- 根据表头、表尾的定义可知：任何一个非空广义表的表头是表中第一个元素，它可以是原子，也可以是子表，而其表尾必定是子表。
- head(L)=a， tail(L)=(b) 　　head(B)=A， tail(B)=(y) 　　由于tail(L)是非空表，可继续分解得到： 　　head(tail(L))=b， tail(tail(L))=()
- 广义表()和(())不同。前者是长度为0的空表，对其不能做求表头和表尾的运算；而后者是长度为l的非空表(只不过该表中惟一的一个元素是空表)，对其可进行分解，得到的表头和表尾均是空表()。 

12、链表结点除自身信息外还包括指针域，因此存储密度小于顺序存储结构，即所占空间大。

13、快速排序

```c
void sort(int *a, int left, int right)
{
    if(left >= right)/*如果左边索引大于或者等于右边的索引就代表已经整理完成一个组了*/
    {
        return ;
    }
    int i = left;
    int j = right;
    int key = a[left];
     
    while(i < j)                               /*控制在当组内寻找一遍*/
    {
        while(i < j && key <= a[j])
        /*而寻找结束的条件就是，1，找到一个小于或者大于key的数（大于或小于取决于你想升
        序还是降序）2，没有符合条件1的，并且i与j的大小没有反转*/ 
        {
            j--;/*向前寻找*/
        }
         
        a[i] = a[j];
        /*找到一个这样的数后就把它赋给前面的被拿走的i的值（如果第一次循环且key是
        a[left]，那么就是给key）*/
         
        while(i < j && key >= a[i])
        /*这是i在当组内向前寻找，同上，不过注意与key的大小关系停止循环和上面相反，
        因为排序思想是把数往两边扔，所以左右两边的数大小与key的关系相反*/
        {
            i++;
        }
         
        a[j] = a[i];
    }
     
    a[i] = key;/*当在当组内找完一遍以后就把中间数key回归*/
    sort(a, left, i - 1);/*最后用同样的方式对分出来的左边的小组进行同上的做法*/
    sort(a, i + 1, right);/*用同样的方式对分出来的右边的小组进行同上的做法*/
                       /*当然最后可能会出现很多分左右，直到每一组的i = j 为止*/
}
```

14、

